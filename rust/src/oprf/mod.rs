//! The `oprf` module provides access to the (V)OPRF API specified in
//! [draft-irtf-cfrg-voprf](https://datatracker.ietf.org/doc/draft-irtf-cfrg-voprf/).
//!
//! # Example
//!
//! Provides a local end-to-end example of the (V)OPRF protocol interaction
//! between server and client.
//!
//! ```
//! use voprf_rs::oprf::groups::PrimeOrderGroup;
//! use voprf_rs::oprf::{Server,Client};
//! use voprf_rs::oprf::ciphersuite::Ciphersuite;
//! use curve25519_dalek::ristretto::RistrettoPoint;
//! use sha2::Sha512;
//!
//! // create Paticipant objects
//! let pog = PrimeOrderGroup::<RistrettoPoint,Sha512>::ristretto_255();
//! let ciph = Ciphersuite::<RistrettoPoint,Sha512>::new(pog.clone(), true);
//! let srv = Server::<RistrettoPoint,Sha512>::setup(ciph.clone());
//! let cli = match Client::<RistrettoPoint,Sha512>::setup(ciph.clone(), Some(srv.key.pub_key(&pog))) {
//!     Ok(c) => c,
//!     Err(e) => panic!(e),
//! };
//!
//! // client generates and blinds a token
//! let mut x: Vec<u8> = Vec::new();
//! (pog.uniform_bytes)(&mut x);
//! let input_vec = cli.blind(&vec![x]);
//!
//! // server evaluates PRF on single input
//! let eval = srv.eval(&vec![input_vec[0].elem]);
//! assert_eq!(eval.elems.len(), 1);
//! if let Some(d) = &eval.proof {
//!     assert_eq!(d.len(), 2)
//! } else {
//!     panic!("a proof should have been provided")
//! }
//!
//! // client unblinds and finalizes the server response response
//! match cli.unblind(&input_vec, &eval) {
//!     Ok(u) => {
//!         let input_data = &input_vec[0].data;
//!         // client finalization_check
//!         let aux = b"auxiliary_data";
//!         let out = match cli.finalize(&input_data, &eval.elems[0], aux) {
//!             Ok(o) => o,
//!             Err(e) => panic!(e)
//!         };
//!     },
//!     Err(e) => panic!(e)
//! }
//! ```


pub mod ciphersuite;
pub mod groups;

use groups::PrimeOrderGroup;
use ciphersuite::Ciphersuite;

use hmac::Mac;

use std::io::Error;
use super::errors::{err_internal,err_public_key_not_found,err_proof_not_found,err_proof_verification};

const OPRF_DST: &'static str = "oprf_derive_output";

/// The `SecretKey` struct provides a wrapper around a number of bytes of
/// varying length.
#[derive(Clone)]
pub struct SecretKey(Vec<u8>);

impl SecretKey {
    /// Constructor for `SecretKey<T,H>` for an underlying group instance of the
    /// form `PrimeOrderGroup<T,H>`.
    pub fn new<T,H>(pog: &PrimeOrderGroup<T,H>) -> Self {
        let mut buf: Vec<u8> = Vec::new();
        (pog.uniform_bytes)(&mut buf);
        SecretKey(buf)
    }

    /// returns the hex value of the secret key
    pub fn as_hex(&self) -> String {
        hex::encode(&self.0)
    }

    /// Computes the corresponding `PublicKey<T>` object for a `SecretKey`
    /// object associated with `PrimeOrderGroup<T,H>`. Essentially computes
    /// `g*k` where `g` is the fixed generator of the group, and where `k` is
    /// the scaalr value of the secret key.
    pub fn pub_key<T,H>(&self, pog: &PrimeOrderGroup<T,H>) -> PublicKey<T>
            where T: Clone {
        PublicKey((pog.scalar_mult)(&pog.generator, &self.0))
    }
}

/// The `PublicKey` object provides a wrapper around a type `T` that is defined
/// to be the type of group elements used in instantiating a group of the form
/// `PrimeOrderGroup<T,H>`.
#[derive(Clone)]
pub struct PublicKey<T>(T);
impl<T> PublicKey<T> {
    /// outputs the (compressed) public key as a hex string
    pub fn as_hex<H>(&self, pog: &PrimeOrderGroup<T,H>) -> String {
        let mut out = Vec::new();
        (pog.serialize)(&self.0, true, &mut out);
        hex::encode(out)
    }

    /// constructs an instance of `PublicKey` from hex input
    pub fn from_hex<H>(hex_str: String, pog: &PrimeOrderGroup<T,H>) -> Self {
        let buf = hex::decode(hex_str).unwrap();
        PublicKey((pog.deserialize)(&buf).unwrap())
    }
}

/// A struct containing data associated with the client input generated for the
/// OPRF protocol. This data is generated by the client initially, and then
/// stored to allow processing the server response in the protocol.
///
/// # Fields
///
/// * `data`: The underlying buffer used for generating the client input
/// * `elem`: A group element equal to `h1(data)*r` where `r` is the scalar
/// respresentation of the blinding factor used
/// * `blind`: The bytes corresponding to the blinding factor that is used
#[derive(Clone)]
pub struct Input<T> {
    /// The initial bytes that characterise the client input
    pub data: Vec<u8>,
    /// The curve point that results from computing ciph.h1(x)*blind, where
    /// ciph.h1 encodes bytes as elements in the prime-order group used by the
    /// (V)OPRF
    pub elem: T,
    /// The value that is used to blind the input by the client, to ensure that
    /// the server does not learn their input
    pub blind: Vec<u8>
}

/// The struct used for wrapping the data generated in the server response.
/// Contains PRF evaluations over the blinded client inputs (and optionally the
/// bytes of a proof object if `ciph.verifiable` is set for the Ciphersuite
/// object).
///
/// # Fields
///
/// * `elems`: A vector of (V)OPRF evaluations (equal to `k*m[i]`) where each
///   `m[i]` is a blinded group element provided by the client.
/// * `proof`: An optional DLEQ proof object that is mandatory if the associated
///   ciphersuite is verifiable.
#[derive(Clone)]
pub struct Evaluation<T>{
    /// The group elements that result from evaluating the PRF on the
    /// server-side
    pub elems: Vec<T>,
    /// Optional proof (for verifiability in VOPRF) for ensuring that the server
    /// evaluates the PRF with a committed key
    pub proof: Option<[Vec<u8>; 2]>
}

/// Defines a struct for (V)OPRF protocol participants. Corresponds to a
/// specific choice of `Ciphersuite<T,H>`, along with a specific key type.
#[derive(Clone)]
pub struct Participant<T,H,K>
        where T: Clone, H: Clone {
    /// The ciphersuite used by the participant
    pub ciph: Ciphersuite<T,H>,
    /// The type of key associated with the `Participant`, either `SecretKey` or
    /// `PublicKey`.
    pub key: K,
}

/// The `Server<T,H>` type wraps an instance of Participant where `K =
/// SecretKey`. Provides functionality for the server-side operations in the
/// (V)OPRF protocol
///
/// # Example
///
/// ```
/// use voprf_rs::oprf::groups::PrimeOrderGroup;
/// use voprf_rs::oprf::Server;
/// use voprf_rs::oprf::ciphersuite::Ciphersuite;
/// use curve25519_dalek::ristretto::RistrettoPoint;
/// use sha2::Sha512;
///
/// // create Server object
/// let pog = PrimeOrderGroup::<RistrettoPoint,Sha512>::ristretto_255();
/// let ciph = Ciphersuite::<RistrettoPoint,Sha512>::new(pog.clone(), false);
/// let srv = Server::<RistrettoPoint,Sha512>::setup(ciph.clone());
///
/// // evaluate (V)OPRF on a group element (computes k*m)
/// let m = ciph.h1(b"some_input_data");
/// let _ = srv.eval(&vec![m]);
/// ```
pub type Server<T,H> = Participant<T,H,SecretKey>;

impl<T,H> Server<T,H>
        where T: Clone, H: Clone {
    /// Creates an instance of the `Server` type from an initial choice of
    /// ciphersuite.
    ///
    /// # Arguments
    ///
    /// * `ciph`: A valid `Ciphersuite<T,H>` object
    pub fn setup(ciph: Ciphersuite<T,H>) -> Self {
        let pog = &ciph.pog.clone();
        Server{
            ciph: ciph,
            key: SecretKey::new(pog),
        }
    }

    /// Corresponds to the (V)OPRF_Eval algorithm in draft-irtf-cfrg-voprf.
    /// Evaluates the server-side PRF portion of the (V)OPRF of the protocol
    ///
    /// # Arguments
    ///
    /// `input_elems`: A slice of group elements (type `T`)
    pub fn eval(&self, input_elems: &[T]) -> Evaluation<T> {
        let mut eval_elems = Vec::new();
        let ciph = &self.ciph;
        let pog = &ciph.pog;
        let key = &self.key;

        // recover secret key value
        let sk = &key.0;
        for m in input_elems {
            eval_elems.push((pog.scalar_mult)(m, sk));
        }

        // generate proof if necessary
        let mut proof = None;
        if ciph.verifiable {
            let pk = key.pub_key(pog).0;
            proof = Some(self.proof_generation(&sk, &pk, input_elems, &eval_elems));
        }

        return Evaluation{
            elems: eval_elems,
            proof: proof,
        };
    }

    /// Evaluates the server-side PRF portion of the (V)OPRF of the protocol
    /// with fixed parameters for testing
    ///
    /// # Arguments
    ///
    /// `input_elems`: A slice of group elements (type `T`)
    pub fn fixed_eval(&self, input_elems: &[T], fixed_scalar: &[u8]) -> Evaluation<T> {
        let mut eval_elems = Vec::new();
        let ciph = &self.ciph;
        let pog = &ciph.pog;
        let key = &self.key;

        // recover secret key value
        let sk = &key.0;
        for m in input_elems {
            eval_elems.push((pog.scalar_mult)(m, sk));
        }

        // generate proof if necessary
        let mut proof = None;
        if ciph.verifiable {
            let pk = key.pub_key(pog).0;
            proof = Some(self.fixed_proof_generation(&sk, &pk, input_elems, &eval_elems, fixed_scalar));
        }

        return Evaluation{
            elems: eval_elems,
            proof: proof,
        };
    }

    /// set_key allows specifying a new key for the server
    pub fn set_key(&mut self, key: Vec<u8>) {
        self.key = SecretKey(key);
    }

    /// generates the DLEQ proof object
    fn proof_generation(&self, sk: &[u8], pk: &T, input_elems: &[T], eval_elems: &[T]) -> [Vec<u8>; 2] {
        match input_elems.len() > 1 {
            true => (self.ciph.pog.batch_dleq_generate)(&sk, &pk, &input_elems, &eval_elems),
            false => (self.ciph.pog.dleq_generate)(&sk, &pk, &input_elems[0], &eval_elems[0])
        }
    }

    /// same as `proof_generation` except that it runs the algorithms with a
    /// fixed scalar, used for testing purposes.
    fn fixed_proof_generation(&self, sk: &[u8], pk: &T, input_elems: &[T], eval_elems: &[T], fixed_scalar: &[u8]) -> [Vec<u8>; 2] {
        match input_elems.len() > 1 {
            true => (self.ciph.pog.fixed_batch_dleq_generate)(&sk, &pk, &input_elems, &eval_elems, fixed_scalar),
            false => (self.ciph.pog.fixed_dleq_generate)(&sk, &pk, &input_elems[0], &eval_elems[0], fixed_scalar)
        }
    }
}

/// The `Client<T,H>` type wraps an instance of Participant where `K =
/// Option<PublicKey<T,H>>`. Provides functionality for the client-side
/// operations in the (V)OPRF protocol. The `key` field may only be `None` in
/// the case where the associated Ciphersuite object satisfies `ciph.verifiable
/// == false`.
///
/// See the example at the top of this docs for more example usage
pub type Client<T,H> = Participant<T,H,Option<PublicKey<T>>>;

impl<T,H> Client<T,H>
        where T: Clone, H: Clone + digest::BlockInput + digest::FixedOutput
        + digest::Input + digest::Reset + std::default::Default,
        PrimeOrderGroup<T, H>: ciphersuite::Supported {
    /// Creates an instance of the `Client` type from an initial choice of
    /// ciphersuite.
    ///
    /// # Arguments
    ///
    /// * `ciph`: A valid `Ciphersuite<T,H>` object
    /// * `pub_key`: An optional `PublicKey<T,H>` object in the case where the
    ///   ciphersuite is verifiable
    pub fn setup(ciph: Ciphersuite<T,H>, pub_key: Option<PublicKey<T>>) -> Result<Self, Error> {
        // verifiable ciphersuites must have a public key set
        if ciph.verifiable {
            if let None = pub_key {
                return Err(err_public_key_not_found());
            }
        }
        Ok(Client{
            ciph: ciph,
            key: pub_key,
        })
    }

    /// Corresponds to the (V)OPRF_Blind algorithm in draft-irtf-cfrg-voprf.
    /// Computes a set of Input objects corresponding to blinded group elements
    /// derived from the input bytes
    ///
    /// # Arguments
    ///
    /// * `inputs`: A slice of byte vectors which the blinded group elements are
    ///   computed from
    pub fn blind(&self, inputs: &[Vec<u8>]) -> Vec<Input<T>> {
        let mut blinded_inputs: Vec<Input<T>> = Vec::new();
        for x in inputs {
            let ciph = &self.ciph;
            let pog = &ciph.pog;
            let mut r: Vec<u8> = Vec::new();
            (pog.uniform_bytes)(&mut r);
            let p = self.blind_fixed(&x, &r);
            blinded_inputs.push(Input{
                data: x.to_vec(),
                elem: p,
                blind: r
            });
        }
        blinded_inputs
    }

    /// Corresponds to blinding a single point with a fixed blind value. Made
    /// public for testing purposes
    ///
    /// # Arguments
    ///
    /// * `inputs`: A slice of bytes which a blinded group element is computed
    ///   from
    /// * `blind`: The blind used to create the blinded group element
    pub fn blind_fixed(&self, input: &[u8], blind: &[u8]) -> T {
        let ciph = &self.ciph;
        let pog = &ciph.pog;
        let t = ciph.h1(&input);
        (pog.scalar_mult)(&t, &blind)
    }

    /// Corresponds to the (V)OPRF_Unblind algorithm in draft-irtf-cfrg-voprf.
    /// Unblinds the output of the server evaluation algorithm, in accordance
    /// with the client-specified inputs. If the client ciphersuite is for a
    /// VOPRF< then it will also verify the server-generated DLEQ proof object.
    ///
    /// # Arguments
    ///
    /// * `inputs`: client-generated (V)OPRF inputs
    /// * `eval`: corresponding server evaluation over client inputs
    pub fn unblind(&self, inputs: &[Input<T>], eval: &Evaluation<T>) -> Result<Vec<T>, Error> {
        let ciph = &self.ciph;
        let pog = &ciph.pog;
        let eval_elems = &eval.elems;
        // check that the number of inputs is the same as the number of outputs
        assert_eq!(inputs.len(), eval_elems.len());
        // verify proof if necessary
        let mut proof_verification = Ok(false);
        if ciph.verifiable {
            // recover proof
            if let Some(d) = &eval.proof {
                if let Some(pk) = &self.key {
                    // get input group elements and verify proof
                    let verify_evals = eval_elems;
                    match inputs.len() > 1 {
                        true => {
                            let mut input_elems = Vec::new();
                            for input in inputs {
                                input_elems.push(input.elem.clone());
                            }
                            proof_verification = Ok((pog.batch_dleq_verify)(&pk.0, &input_elems, &verify_evals, &d));
                        },
                        false => {
                            proof_verification = Ok((pog.dleq_verify)(&pk.0, &inputs[0].elem, &verify_evals[0], &d));
                        }
                    };
                } else {
                    proof_verification = Err(err_public_key_not_found());
                }
            } else {
                proof_verification = Err(err_proof_not_found());
            }
        }
        let mut outs: Vec<T> = Vec::new();
        for i in 0..eval_elems.len() {
            let elem = &eval_elems[i];
            let blind = &inputs[i].blind;
            outs.push((pog.inverse_mult)(elem, blind));
        }

        if ciph.verifiable {
            if let Ok(b) = proof_verification {
                // if false, then the proof failed to verify
                if !b {
                    return Err(err_proof_verification());
                }
            }
        }
        Ok(outs)
    }

    /// Corresponds to the (V)OPRF_Finalize algorithm in draft-irtf-cfrg-voprf.
    /// Completes the (V)OPRF protocol by computing an HMAC tag (over arbitrary
    /// data `aux`) from each (V)OPRF evaluation.
    ///
    /// # Arguments
    ///
    /// * `input_data`: slice corresponding to the initial bytes of each client
    ///   input (i.e. `Input.data`).
    /// * `elem`: unblinded group element recovered from (V)OPRF_Unblind
    ///   algorithm.
    /// * `aux`: arbitrary bytes used to evaluate finalization HMAC.
    pub fn finalize(&self, input_data: &[u8], elem: &T, aux: &[u8]) -> Result<Vec<u8>, Error> {
        let ciph = &self.ciph;
        let pog = &ciph.pog;

        // derive shared key
        match ciph.h2(&String::from(OPRF_DST).as_bytes()) {
            Ok(mut mac) => {
                mac.input(input_data);
                let mut ser: Vec<u8> = Vec::new();
                (pog.serialize)(&elem, true, &mut ser);
                mac.input(&ser);
                let dk = mac.result().code().to_vec();

                // derive output
                match ciph.h2(&dk) {
                    Ok(mut inner_mac) => {
                        inner_mac.input(&aux);
                        Ok(inner_mac.result().code().to_vec())
                    },
                    Err(_) => Err(err_internal())
                }
            },
            Err(_) => Err(err_internal())
        }
    }
}

#[cfg(test)]
mod tests {
    use super::groups::PrimeOrderGroup;
    use super::{Client,Server,Ciphersuite,Input,Evaluation};
    use super::ciphersuite::Supported;
    use curve25519_dalek::ristretto::RistrettoPoint;
    use super::groups::p384::NistPoint;
    use sha2::Sha512;

    #[test]
    fn end_to_end_oprf_ristretto() {
        let pog = PrimeOrderGroup::<RistrettoPoint,Sha512>::ristretto_255();
        let ciph = Ciphersuite::<RistrettoPoint,Sha512>::new(pog.clone(), false);
        let srv = Server::<RistrettoPoint,Sha512>::setup(ciph.clone());
        let cli = match Client::<RistrettoPoint,Sha512>::setup(ciph.clone(), None) {
            Ok(c) => c,
            Err(e) => panic!(e),
        };

        end_to_end_oprf(srv, cli, pog, ciph)
    }

    #[test]
    fn end_to_end_voprf_ristretto() {
        let pog = PrimeOrderGroup::<RistrettoPoint,Sha512>::ristretto_255();
        let ciph = Ciphersuite::<RistrettoPoint,Sha512>::new(pog.clone(), true);
        let srv = Server::<RistrettoPoint,Sha512>::setup(ciph.clone());
        let cli = match Client::<RistrettoPoint,Sha512>::setup(ciph.clone(), Some(srv.key.pub_key(&pog))) {
            Ok(c) => c,
            Err(e) => panic!(e),
        };

        end_to_end_voprf(srv, cli, pog, ciph)
    }

    #[test]
    fn end_to_end_batch_oprf_ristretto() {
        let pog = PrimeOrderGroup::<RistrettoPoint,Sha512>::ristretto_255();
        let ciph = Ciphersuite::<RistrettoPoint,Sha512>::new(pog.clone(), false);
        let srv = Server::<RistrettoPoint,Sha512>::setup(ciph.clone());
        let cli = match Client::<RistrettoPoint,Sha512>::setup(ciph.clone(), None) {
            Ok(c) => c,
            Err(e) => panic!(e),
        };

        end_to_end_batch_oprf(srv, cli, pog, ciph)
    }

    #[test]
    fn end_to_end_batch_voprf_ristretto() {
        let pog = PrimeOrderGroup::<RistrettoPoint,Sha512>::ristretto_255();
        let ciph = Ciphersuite::<RistrettoPoint,Sha512>::new(pog.clone(), true);
        let srv = Server::<RistrettoPoint,Sha512>::setup(ciph.clone());
        let cli = match Client::<RistrettoPoint,Sha512>::setup(ciph.clone(), Some(srv.key.pub_key(&pog))) {
            Ok(c) => c,
            Err(e) => panic!(e),
        };

        end_to_end_batch_voprf(srv, cli, pog, ciph)
    }

    #[test]
    fn end_to_end_oprf_p384() {
        let pog = PrimeOrderGroup::<NistPoint,Sha512>::p384();
        let ciph = Ciphersuite::<NistPoint,Sha512>::new(pog.clone(), false);
        let srv = Server::<NistPoint,Sha512>::setup(ciph.clone());
        let cli = match Client::<NistPoint,Sha512>::setup(ciph.clone(), None) {
            Ok(c) => c,
            Err(e) => panic!(e),
        };

        end_to_end_oprf(srv, cli, pog, ciph)
    }

    #[test]
    fn end_to_end_voprf_p384() {
        let pog = PrimeOrderGroup::<NistPoint,Sha512>::p384();
        let ciph = Ciphersuite::<NistPoint,Sha512>::new(pog.clone(), true);
        let srv = Server::<NistPoint,Sha512>::setup(ciph.clone());
        let cli = match Client::<NistPoint,Sha512>::setup(ciph.clone(), Some(srv.key.pub_key(&pog))) {
            Ok(c) => c,
            Err(e) => panic!(e),
        };

        end_to_end_voprf(srv, cli, pog, ciph)
    }

    #[test]
    fn end_to_end_batch_oprf_p384() {
        let pog = PrimeOrderGroup::<NistPoint,Sha512>::p384();
        let ciph = Ciphersuite::<NistPoint,Sha512>::new(pog.clone(), false);
        let srv = Server::<NistPoint,Sha512>::setup(ciph.clone());
        let cli = match Client::<NistPoint,Sha512>::setup(ciph.clone(), None) {
            Ok(c) => c,
            Err(e) => panic!(e),
        };

        end_to_end_batch_oprf(srv, cli, pog, ciph)
    }

    #[test]
    fn end_to_end_batch_voprf_p384() {
        let pog = PrimeOrderGroup::<NistPoint,Sha512>::p384();
        let ciph = Ciphersuite::<NistPoint,Sha512>::new(pog.clone(), true);
        let srv = Server::<NistPoint,Sha512>::setup(ciph.clone());
        let cli = match Client::<NistPoint,Sha512>::setup(ciph.clone(), Some(srv.key.pub_key(&pog))) {
            Ok(c) => c,
            Err(e) => panic!(e),
        };

        end_to_end_batch_voprf(srv, cli, pog, ciph)
    }

    fn end_to_end_oprf<T,H>(srv: Server<T,H>, cli: Client<T,H>, pog: PrimeOrderGroup<T,H>, ciph: Ciphersuite<T,H>)
            where  Input<T>: Clone, Evaluation<T>: Clone, T: Clone, H: Clone
            + digest::BlockInput + digest::FixedOutput + digest::Input
            + digest::Reset + std::default::Default,
            PrimeOrderGroup<T, H>: Supported, Client<T,H>: Clone {
        // generate and blind a token
        let mut x: Vec<u8> = Vec::new();
        (pog.uniform_bytes)(&mut x);
        let input_vec = cli.blind(&vec![x]);

        // evaluate PRF on single input
        let eval = srv.eval(&vec![input_vec[0].elem.clone()]);
        assert_eq!(eval.elems.len(), 1);
        if let Some(_) = eval.proof {
            panic!("no proof should have been provided")
        }

        // unblind and check finalization
        unblind_and_check(srv, &cli, &ciph, input_vec, &eval);
    }

    fn end_to_end_batch_oprf<T,H>(srv: Server<T,H>, cli: Client<T,H>, pog: PrimeOrderGroup<T,H>, ciph: Ciphersuite<T,H>)
            where  Input<T>: Clone, Evaluation<T>: Clone, T: Clone, H: Clone
            + digest::BlockInput + digest::FixedOutput + digest::Input
            + digest::Reset + std::default::Default,
            PrimeOrderGroup<T, H>: Supported, Client<T,H>: Clone {
        // generate and blind a token
        let mut input_data_vec = Vec::new();
        let mut x: Vec<u8> = Vec::new();
        for _ in 0..5 {
            (pog.uniform_bytes)(&mut x);
            input_data_vec.push(x.clone());
        }
        let input_vec = cli.blind(&input_data_vec);

        // evaluate PRF on single input
        let mut input_elems = Vec::new();
        for input in &input_vec {
            input_elems.push(input.elem.clone());
        }
        let eval = srv.eval(&input_elems);
        assert_eq!(eval.elems.len(), 5);
        if let Some(_) = eval.proof {
            panic!("no proof should have been provided")
        }

        // unblind and check finalization
        unblind_and_check(srv, &cli, &ciph, input_vec, &eval);
    }

    fn end_to_end_voprf<T,H>(srv: Server<T,H>, cli: Client<T,H>, pog: PrimeOrderGroup<T,H>, ciph: Ciphersuite<T,H>)
            where  Input<T>: Clone, Evaluation<T>: Clone, T: Clone, H: Clone
            + digest::BlockInput + digest::FixedOutput + digest::Input
            + digest::Reset + std::default::Default,
            PrimeOrderGroup<T, H>: Supported, Client<T,H>: Clone {
        // generate and blind a token
        let mut x: Vec<u8> = Vec::new();
        (pog.uniform_bytes)(&mut x);
        let input_vec = cli.blind(&vec![x]);

        // evaluate PRF on single input
        let eval = srv.eval(&vec![input_vec[0].elem.clone()]);
        assert_eq!(eval.elems.len(), 1);
        if let Some(d) = &eval.proof {
            assert_eq!(d.len(), 2)
        } else {
            panic!("a proof should have been provided")
        }

        // unblind and check finalization
        unblind_and_check(srv, &cli, &ciph, input_vec, &eval);
    }

    fn end_to_end_batch_voprf<T,H>(srv: Server<T,H>, cli: Client<T,H>, pog: PrimeOrderGroup<T,H>, ciph: Ciphersuite<T,H>)
            where  Input<T>: Clone, Evaluation<T>: Clone, T: Clone, H: Clone
            + digest::BlockInput + digest::FixedOutput + digest::Input
            + digest::Reset + std::default::Default,
            PrimeOrderGroup<T, H>: Supported, Client<T,H>: Clone {
        // generate and blind a token
        let mut input_data_vec = Vec::new();
        let mut x: Vec<u8> = Vec::new();
        for _ in 0..5 {
            (pog.uniform_bytes)(&mut x);
            input_data_vec.push(x.clone());
        }
        let input_vec = cli.blind(&input_data_vec);

        // evaluate PRF on single input
        let mut input_elems = Vec::new();
        for input in &input_vec {
            input_elems.push(input.elem.clone());
        }
        let eval = srv.eval(&input_elems);
        assert_eq!(eval.elems.len(), 5);
        if let Some(d) = eval.proof.clone() {
            assert_eq!(d.len(), 2)
        } else {
            panic!("a proof should have been provided")
        }

        // unblind and check finalization
        unblind_and_check(srv, &cli, &ciph, input_vec, &eval);
    }

    fn unblind_and_check<T,H>(srv: Server<T,H>, cli: &Client<T,H>, ciph: &Ciphersuite<T,H>, input_vec: Vec<Input<T>>, eval: &Evaluation<T>)
            where Input<T>: Clone, Evaluation<T>: Clone, T: Clone, H: Clone
            + digest::BlockInput + digest::FixedOutput + digest::Input
            + digest::Reset + std::default::Default,
            PrimeOrderGroup<T, H>: Supported, Client<T,H>: Clone {
        // unblind server evaluation
        match cli.unblind(&input_vec, eval) {
            Ok(u) => {
                let sk = srv.key.0;
                for i in 0..input_vec.len() {
                    let input_data = &input_vec[i].data;
                    finalization_check(cli, &sk, ciph, input_data, &u[i]);
                }
            },
            Err(e) => panic!(e)
        }
    }

    fn finalization_check<T,H>(cli: &Client<T,H>, sk: &[u8], ciph: &Ciphersuite<T,H>, input_data: &[u8], evals: &T)
            where Input<T>: Clone, Evaluation<T>: Clone, T: Clone, H: Clone
            + digest::BlockInput + digest::FixedOutput + digest::Input
            + digest::Reset + std::default::Default,
            PrimeOrderGroup<T, H>: Supported, Client<T,H>: Clone {
        // finalize output
        let aux = b"auxiliary_data";
        let out = match cli.finalize(&input_data, &evals, aux) {
            Ok(o) => o,
            Err(e) => panic!(e)
        };

        // check output with server (without blinding)
        let ge = ciph.h1(&input_data);
        let chk_eval = (ciph.pog.scalar_mult)(&ge, &sk);
        let chk_out = match cli.finalize(&input_data, &chk_eval, aux) {
            Ok(o) => o,
            Err(e) => panic!(e)
        };

        // check that the outputs are consistent
        assert_eq!(out, chk_out);
    }
}